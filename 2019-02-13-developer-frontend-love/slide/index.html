<html>
    <head>
        <link
            rel="stylesheet"
            href="../asset/vendor/reveal.js-3.7.0/css/reveal.css"
        />
        <link rel="stylesheet" href="../asset/vendor/prism-1.15.0/prism.css" />
        <link rel="stylesheet" href="../asset/peerigon/theme-peerigon.css" />
    </head>
    <body id="peerigon">
        <div class="reveal">
            <div class="slides">
                <section
                    id="first-slide"
                    data-background-image="../asset/amsterdam.jpg"
                    data-background-color="black"
                    data-background-opacity="0.5"
                >
                    <style>
                        #first-slide h1 {
                            color: white;
                        }

                        #first-slide .credit {
                            font-size: 1rem;
                            position: fixed;
                            bottom: 10px;
                            opacity: 0.5;
                        }
                    </style>
                    <div class="kicker">Developer Frontend Love</div>
                    <h1>The future of JavaScript bundlers.</h1>
                    <span class="credit">
                        Photo by azhrjl on Unsplash
                    </span>
                </section>
                <section>
                    <section data-background-color="var(--color-whiskey-bg)">
                        <h2>About me</h2>
                    </section>
                    <section>
                        <div style="text-align: center">
                            <img
                                src="../asset/me/me.svg"
                                style="width: 100%;"
                                alt="Image of Johannes Ewald"
                            />
                        </div>
                    </section>
                    <section>
                        <div style="text-align: center">
                            <img
                                src="../asset/peerigon/peerigon-logo-flat-whiskey.svg"
                                width="600"
                                alt="Peerigon logo"
                            />
                        </div>
                    </section>
                    <section>
                        <div style="text-align: center">
                            <img
                                src="../asset/me/webpack-logo.svg"
                                width="700"
                                alt="Webpack logo"
                            />
                        </div>
                    </section>
                </section>
                <section>
                    <section data-background-color="var(--color-whiskey-bg)">
                        <h2>Do we even need JavaScript bundlers?</h2>
                        <!-- TODO: Idea: Amsterdam image -->
                    </section>
                    <section>
                        <div class="kicker">
                            Problems with JavaScript bundlers
                        </div>
                        <h3>There is a build step.</h3>
                        <ul>
                            <li class="fragment">Might be slow</li>
                            <li class="fragment">Adds additional complexity</li>
                        </ul>
                    </section>
                    <section>
                        <div class="kicker">
                            Problems with JavaScript bundlers
                        </div>
                        <h3>You have to configure it.</h3>
                        <ul>
                            <li class="fragment">
                                For special dialects like JSX or CSS modules
                            </li>
                            <li class="fragment">#0CJS is a good start...</li>
                            <li class="fragment">
                                ...but every reasonable-sized app will
                                eventually require custom configuration
                            </li>
                        </ul>
                    </section>
                    <section>
                        <div class="kicker">
                            Problems with JavaScript bundlers
                        </div>
                        <h3>Additional indirection.</h3>
                        <ul>
                            <li class="fragment">
                                The code you write is not the code that is
                                executed
                            </li>
                            <li class="fragment">
                                Configuring source maps can be error prone
                            </li>
                            <li class="fragment">
                                Source maps are slow to generate
                            </li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            You suddenly have to deal with problems you didn't
                            have before.
                        </p>
                    </section>
                    <section>
                        <h3>Native ES modules support in browsers</h3>
                        <p>
                            <!-- TODO: Add caniuse -->
                        </p>
                    </section>
                    <section>
                        <p>
                            Why isn't everyone just using ES modules?
                        </p>
                    </section>
                    <section>
                        <div style="text-align: center">
                            <img
                                src="../asset/bare-specifier-error.jpg"
                                alt="Image of a resolve module error"
                                width="900"
                            />
                        </div>
                    </section>
                    <section>
                        <h3>No bare module specifiers.</h3>
                        <pre data-src="../example/bareModuleSpecifier.js"></pre>
                    </section>
                    <section>
                        <h3>No optional extensions.</h3>
                        <pre data-src="../example/optionalExtension.js"></pre>
                    </section>
                    <section>
                        <h3>No <code>package.json</code> resolving.</h3>
                        <pre
                            data-src="../example/packageJsonResolving.json"
                        ></pre>
                    </section>
                    <section>
                        <p>
                            Since URL lookups are expensive, the browser can't
                            just try out a bunch of possibilities like Node.js
                            does.
                        </p>
                    </section>
                    <section>
                        <p>
                            Will we still need JavaScript bundlers in the
                            future?
                        </p>
                    </section>
                </section>
                <section>
                    <section data-background-color="var(--color-whiskey-bg)">
                        <h2>The purpose of JavaScript bundlers.</h2>
                    </section>
                    <section id="feature-table-1">
                        <style>
                            #feature-table-1 tbody {
                                visibility: hidden;
                            }
                        </style>
                        <feature-table></feature-table>
                    </section>
                    <section>
                        <div class="kicker">Dev experience</div>
                        <h3>
                            They enable JavaScript modules in all browsers.
                        </h3>
                        <!-- TODO: Fix headline line-height -->
                        <!--TODO: Hooray emojii? -->
                    </section>
                    <section>
                        <div class="kicker">Dev experience</div>
                        <h3>HTML, CSS and WebAssembly modules.</h3>
                    </section>
                    <section>
                        <div class="kicker">Dev experience</div>
                        <h3>
                            They allow us to use custom languages.
                        </h3>
                        <ul>
                            <li class="fragment">JSX</li>
                            <li class="fragment">Vue Single-File Components</li>
                            <li class="fragment">TypeScript</li>
                        </ul>
                    </section>
                    <section>
                        <div class="kicker">Dev experience</div>
                        <h3>Short feedback loop.</h3>
                        <ul>
                            <li class="fragment">
                                Fast rebuilds in watch mode
                            </li>
                            <li class="fragment">Hot module replacement</li>
                            <!--TODO: Hooray emojii? -->
                        </ul>
                    </section>
                    <section id="feature-table-2">
                        <style>
                            #feature-table-2 tbody tr td:not(:first-child) {
                                visibility: hidden;
                            }
                        </style>
                        <feature-table></feature-table>
                    </section>
                    <section>
                        <div class="kicker">Compatibility</div>
                        <h3>They unify module systems.</h3>
                        <p class="fragment">
                            Like ESM, CJS, even WASM and mabe even still AMD.
                        </p>
                    </section>
                    <section>
                        <p>
                            They take care of...
                        </p>
                        <ul>
                            <li class="fragment">
                                ...wiring all imports and exports together
                            </li>
                            <li class="fragment">
                                ...initializing the module graph
                            </li>
                        </ul>
                        <p class="fragment">
                            You don't need to worry about what module system
                            your dependencies are using.
                        </p>
                    </section>
                    <section>
                        <div class="kicker">Compatibility</div>
                        <h3>They unify the underlying platform.</h3>
                        <p class="fragment">
                            Historically, we tried to simulate a CJS environment
                            with Node.js core modules.
                        </p>
                    </section>
                    <section>
                        <div class="kicker">Compatibility</div>
                        <h3>They compile down new language features.</h3>
                        <p class="fragment">
                            Via build tools like Babel and PostCSS.
                        </p>
                    </section>
                    <section id="feature-table-3">
                        <style>
                            #feature-table-3 tbody tr td:nth-child(3) {
                                visibility: hidden;
                            }
                        </style>
                        <feature-table></feature-table>
                    </section>
                    <section>
                        <div class="kicker">Optimization</div>
                        <h3>They create efficient chunks.</h3>
                        <ul>
                            <li class="fragment">
                                By resolving module ids on build time
                            </li>
                            <li class="fragment">
                                By merging modules that depend on each other
                                into a single file.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <div class="kicker">Optimization</div>
                        <h3>
                            They allow us to do effective long-term caching.
                        </h3>
                        <p class="fragment">
                            By calculating asset hashes and automatically
                            updating all URLs.
                        </p>
                    </section>
                    <section>
                        <div class="kicker">Optimization</div>
                        <h3>They add resource hints for the browser.</h3>
                    </section>
                    <section>
                        <div class="kicker">Optimization</div>
                        <h3>They reduce asset file sizes.</h3>
                        <p class="fragment">
                            By removing...
                        </p>
                        <ul>
                            <li class="fragment">
                                unused code (a.k.a. tree-shaking and dead code
                                elimination)
                            </li>
                            <li class="fragment">
                                redundant characters (minification)
                            </li>
                            <li class="fragment">
                                unnecessary bytes (compression)
                            </li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            <strong>Well...</strong>
                        </p>
                        <p>
                            ...they don't actually do the latter, but they
                            orchestrate other tools which do that.
                        </p>
                    </section>
                    <section id="feature-table-4">
                        <feature-table></feature-table>
                    </section>
                </section>
                <section>
                    <section data-background-color="var(--color-whiskey-bg)">
                        <h2>The future of JavaScript bundlers.</h2>
                    </section>
                    <section>
                        <div class="kicker">Dev experience</div>
                        <h3>
                            JS modules.
                        </h3>
                        <p class="fragment">
                            We don't need JS bundlers for that, it's already
                            possible with ESM.
                        </p>
                        <p class="fragment">
                            <strong>But:</strong> our current problem is
                            resolving.
                        </p>
                    </section>
                    <section>
                        <p>
                            Things we can do:
                            <span class="fragment"
                                >not rely on
                                <a
                                    href="https://www.youtube.com/watch?v=M3BM9TB-8yA"
                                    target="_blank"
                                    >"cute" (Ryan Dahl)</a
                                >
                                resolving features.</span
                            >
                        </p>
                    </section>
                    <section>
                        <ul>
                            <li>
                                Use file extensions
                            </li>
                            <li class="fragment">
                                Use the <code>.mjs</code> extension for
                                JavaScript modules once ESMs land in Node.js
                            </li>
                            <li class="fragment">
                                Avoid <code>index.js</code>
                            </li>
                            <li class="fragment">
                                Avoid module aliases just for ergonomic reasons
                            </li>
                        </ul>
                    </section>
                    <section
                        id="real-path"
                        data-background-video="../asset/mind-blown.mp4"
                        data-background-video-loop
                        data-background-opacity="0.3"
                        data-background-color="black"
                    >
                        <style>
                            #real-path h3 {
                                color: white;
                            }
                        </style>
                        <strong>
                            Just use the real path.
                        </strong>
                    </section>
                    <section>
                        <h3>
                            But do we really have to give up bare module
                            specifiers (BMS)?
                        </h3>
                    </section>
                    <section>
                        <p>
                            Advantages of BMS:
                        </p>
                        <ul>
                            <li class="fragment">
                                Shorter imports for common packages
                            </li>
                            <li class="fragment">
                                Indirection at package-level which allows the
                                main/browser switch.
                                <small
                                    >This is important for isomorphic modules
                                    like <code>isomorphic-fetch</code>.</small
                                >
                            </li>
                            <li class="fragment">
                                Hides the actual file layout of third-party
                                modules
                            </li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            There are two ways we could get BMS into the
                            browser:
                        </p>
                        <ul>
                            <li class="fragment">
                                A strict and universal standard how to look up
                                BMS (and all packages would need to adhere to
                                it)
                            </li>
                            <li class="fragment">
                                An external resolving config (out-of-band
                                configuration)
                            </li>
                        </ul>
                    </section>
                    <section data-background-image="../asset/import-maps.jpg" data-background-size="contain"></section>
                    <section>
                        <pre data-src="../example/importMapsSimple.html"></pre>
                    </section>
                    <section>
                        <p>
                            You can also define fallbacks:
                        </p>
                        <pre
                            data-src="../example/importMapsFallback.html"
                        ></pre>
                    </section>
                    <section>
                        <p>
                            There are also scopes that allow to map a BMS to
                            different locations depending on the importing
                            module:
                        </p>
                        <pre data-src="../example/importMapsScope.html"></pre>
                    </section>
                    <section>
                        <h3>
                            But do we have to groom these import maps by hand?
                        </h3>
                    </section>
                    <section>
                        <p>
                            <strong>No.</strong> It will probably be generated
                            by package managers.
                        </p>
                        <p class="fragment">
                            But we will need to tweak it once in a while.
                        </p>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark class="fragment" slot="js-modules" value="ok"></check-mark>
                        </feature-table>
                    </section>
                    <section>
                        <h3>Heads up!</h3>
                        <p>
                            The following proposals are in very early stages.
                            Take them with a grain of salt.
                        </p>
                    </section>
                    <section data-background-image="../asset/html-modules.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            As a replacement for <a href="https://w3c.github.io/webcomponents/spec/imports/" target="_blank">HTML imports</a>:
                        </p>
                        <pre data-src="../example/htmlModuleSimple.html"></pre>
                        <pre data-src="../example/htmlModuleSimple.js"></pre>
                    </section>
                    <section>
                        <pre data-src="../example/htmlModuleAdvanced.html"></pre>
                    </section>
                    <section>
                        <pre data-src="../example/htmlModuleAdvanced.js"></pre>
                    </section>
                    <section>
                        <p>
                            There is an <a href="https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/ewfRSdqcOd8/w_Fr6rJ3DQAJ" target="_blank">intent to implement from the MS Edge team</a>.
                        </p>
                    </section>
                    <section data-background-image="../asset/css-modules.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            Built upon the <a href="https://wicg.github.io/construct-stylesheets/index.html" target="_blank">Constructable Stylesheet Objects proposal</a>.
                        </p>
                    </section>
                    <section>
                        <pre data-src="../example/cssModule.js"></pre>
                    </section>
                    <section data-background-image="../asset/json-modules.jpg" data-background-size="contain"></section>
                    <section data-background-image="../asset/wasm-modules.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            <strong>The goal:</strong> Turn this imperative API...
                        </p>
                        <pre data-src="../example/wasmModule1.js"></pre>
                    </section>
                    <section>
                        <p>
                            ...into a declarative API:
                        </p>
                        <pre data-src="../example/wasmModule2.js"></pre>
                    </section>
                    <section>
                        <div style="display: grid; grid-template-columns: 1fr 3fr; grid-gap: 50px;">
                            <p>
                                <strong>Challenge:</strong> Allow cyclic dependencies between non-JS modules.
                            </p>
                            <img src="../asset/wasm-cyclic-1.png" style="width: 300px; display: block; margin: 0 auto;">
                            <small style="grid-column: 1 / 3; text-align: center;">
                                Source: <a href="https://linclark.github.io/wasm-es-modules/slides/2018-03-24/" target="_blank">Lin Clark's presentation about WebAssembly ES module integration.</a>
                            </small>
                        </div>
                    </section>
                    <section>
                        <div style="display: grid; grid-template-columns: 1fr 3fr; grid-gap: 50px;">
                            <p>
                                Cyclic dependencies between two WASM modules probably won't work at all.
                            </p>
                            <img src="../asset/wasm-cyclic-2.png" style="width: 300px; display: block; margin: 0 auto;">
                            <small style="grid-column: 1 / 3; text-align: center;">
                                Source: <a href="https://linclark.github.io/wasm-es-modules/slides/2018-03-24/" target="_blank">Lin Clark's presentation about WebAssembly ES module integration.</a>
                            </small>
                        </div>
                    </section>
                    <!-- TODO: Speaking of WebAssembly: Will we publish any language on NPM? No -->
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark class="fragment" slot="html-css-wasm-modules" value="maybe"></check-mark>
                        </feature-table>
                    </section>
                    <section data-background-image="../asset/loader-spec.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            <a href="https://github.com/whatwg/loader/issues/147" target="_blank">Has been paused and broken down into smaller pieces like:</a>
                        </p>
                        <pre data-src="../example/dynamicImport.js"></pre>
                    </section>
                    <section>
                        <h3>
                            Interesting proposals
                        </h3>
                    </section>
                    <section>
                        <p>
                            <a href="https://github.com/sebmarkbage/ecmascript-asset-references" target="_blank">
                                Asset references
                            </a>
                        </p>
                        <pre data-src="../example/assetReferences.js"></pre>
                    </section>
                    <section>
                        <p>
                            <a href="https://github.com/AshleyScirra/import-as-and-html-modules" target="_blank">
                                import as-proposal
                            </a>
                        </p>
                        <pre data-src="../example/importAs.js"></pre>
                    </section>
                    <section>
                        <p>
                            Advantages of these proposals:
                        </p>
                        <ul>
                            <li class="fragment">
                                No out-of-band configuration of loaders. Modules determine how they want to import a dependency.
                            </li>
                            <li class="fragment">
                                Custom language support for NPM modules. Sharing frontend components would become easier.
                            </li>
                            <li class="fragment">
                                One step closer to <code>#0CJS</code> (zero config).
                            </li>
                        </ul>
                    </section>
                    <section>
                        <p>
                            <strong>One thing to note:</strong>
                        </p>
                        <p class="fragment">
                            These are proposals to do the resource transformation on run time.
                        </p>
                        <p class="fragment">
                            In order to get it fast for production, you would probably want to move this transformation to build time.
                        </p>
                        <p class="fragment">
                            <strong>
                                Hence, the transformation should be statically analyzable.
                            </strong>
                        </p>
                    </section>
                    <section>
                        <!-- TODO: https://giphy.com/gifs/sad-crying-tear-6qFFgNgextP9u -->
                        <p>
                            This is kind of hard to standardize because bundlers, Node.js and browsers have very different requirements.
                        </p>
                        <p class="fragment">
                            But there is an interesting alternative to loaders...
                        </p>
                    </section>
                    <section data-background-image="../asset/babel-macros.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            Babel macros is a Babel plugin that allows you to evaluate code on build time.
                        </p>
                    </section>
                    <section>
                        <pre data-src="../example/babelMacroPreval.js"></pre>
                        Also the <code>import</code> is removed.
                    </section>
                    <section>
                        <pre data-src="../example/babelMacroMs.js"></pre>
                    </section>
                    <section>
                        <p>
                            How can this substitute loaders?
                        </p>
                    </section>
                    <section>
                        <pre data-src="../example/babelMacroRaw.js"></pre>
                    </section>
                    <section>
                        <pre data-src="../example/babelMacroGraphQl.js"></pre>
                    </section>
                    <section>
                        <p>
                            A good example of why modules should be able to control their loaders:
                        </p>
                        <pre class="fragment" data-src="../example/babelMacroImage.js"></pre>
                    </section>
                    <section>
                        <p>
                            How would that work without Babel?
                        </p>
                    </section>
                    <section>
                        <p>
                            With a <strong>package switch</strong>:
                        </p>
                        <pre data-src="../example/babelMacroPackage.json"></pre>
                    </section>
                    <section>
                        <p>
                            <strong>Current problem of Babel macros</strong>:
                        </p>
                        <p class="fragment">
                            They require synchronous I/O. Maybe this could be solved with top-level await?
                        </p>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark slot="html-css-wasm-modules" value="maybe"></check-mark>
                            <check-mark class="fragment" slot="custom-languages" value="maybe"></check-mark>
                        </feature-table>
                    </section>
                    <section>
                        <h3>Short feedback loop</h3>
                        <ul>
                            <li class="fragment">
                                We do not need a build step at all if we can do the transformations on run time.
                            </li>
                            <li class="fragment">
                                <strong>But:</strong> we would need a way to make the transformations cacheable.
                            </li>
                            <li class="fragment">
                                For HMR, we would still need a dev server with WebSockets.
                            </li>
                        </ul>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark slot="html-css-wasm-modules" value="maybe"></check-mark>
                            <check-mark slot="custom-languages" value="maybe"></check-mark>
                            <check-mark class="fragment" slot="short-feedback-loop" value="maybe"></check-mark>
                        </feature-table>
                    </section>
                    <section>
                        <h3>
                            Unified module systems.
                        </h3>
                        <p class="fragment">
                            Authors will slowly adopt the common denominator:
                        </p>
                        <ul>
                            <li class="fragment">ESM</li>
                            <li class="fragment">Imports with explicit file extensions</li>
                            <li class="fragment">Using the <code>.mjs</code> file extension for ESMs</li>
                        </ul>
                    </section>
                    <section>
                        <!-- TODO: Celebrate gif https://giphy.com/gifs/mrw-metal-spinning-ZUomWFktUWpFu -->
                        <p>
                            <strong>Bundlers won't be necessary because of compatibility reasons.</strong><br>
                            🎉🎉🎉
                        </p>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark slot="html-css-wasm-modules" value="maybe"></check-mark>
                            <check-mark slot="custom-languages" value="maybe"></check-mark>
                            <check-mark slot="short-feedback-loop" value="maybe"></check-mark>
                            <check-mark class="fragment" slot="unified-module-systems" value="ok"></check-mark>
                        </feature-table>
                    </section>
                    <section>
                        <h3>Unified platform.</h3>
                        <p class="fragment">
                            <strong>My hope:</strong> Platform independent APIs will converge some day.
                        </p>
                    </section>
                    <section>
                        <p>
                            Good example: the <code>URL</code> constructor.
                        </p>
                        <pre data-src="../example/whatwgUrl.js"></pre>
                    </section>
                    <section>
                        <p>
                            Bad example: <code>fetch()</code>.
                        </p>
                        <pre data-src="../example/fetch.js"></pre>
                    </section>
                    <section data-background-image="../asset/std-lib.jpg" data-background-size="contain"></section>
                    <section>
                        <p>
                            Would alleviate the need for <a href="https://github.com/webpack/node-libs-browser" target="_blank">node-libs-browser</a>.
                        </p>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark slot="html-css-wasm-modules" value="maybe"></check-mark>
                            <check-mark slot="custom-languages" value="maybe"></check-mark>
                            <check-mark slot="short-feedback-loop" value="maybe"></check-mark>
                            <check-mark slot="unified-module-systems" value="ok"></check-mark>
                            <check-mark class="fragment" slot="unified-platform" value="maybe"></check-mark>
                        </feature-table>
                    </section>
                    <section>
                        <h3>
                            New language features
                        </h3>
                        <p class="fragment">
                            Will be less relevant with evergreen browsers and incremental language updates.
                        </p>
                    </section>
                    <section>
                        <feature-table>
                            <check-mark slot="js-modules" value="ok"></check-mark>
                            <check-mark slot="html-css-wasm-modules" value="maybe"></check-mark>
                            <check-mark slot="custom-languages" value="maybe"></check-mark>
                            <check-mark slot="short-feedback-loop" value="maybe"></check-mark>
                            <check-mark slot="unified-module-systems" value="ok"></check-mark>
                            <check-mark slot="unified-platform" value="maybe"></check-mark>
                            <check-mark class="fragment" slot="new-language-features" value="ok"></check-mark>
                        </feature-table>
                    </section>
                </section>
                <!--
    - Module resolution
        - One of the reasons why bundling will stay relevant in the near future
        - Can currently only be solved with two solutions:
            - Bundling
                - Does not use native ES modules anymore
                - JS engines are not optimized yet to handle a lot of modules
            - H2 Server Push
                - Can also be solved with two different solutions
                    - Dependency graphs generated on build time
                    - Empiric approaches like [https://github.com/google/node-h2-auto-push](https://github.com/google/node-h2-auto-push) (requires sharing sessions, might be hard with load balancers)
                - H2 Push is still hard
                    - [https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit](https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit) (only push critical resources, preload may be easier)
                    - [https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/) (inconsistent implementations)
        - Interesting field and requires constant re-evaluation
    - Chunking and resource hints
        - Problem: Webpack is already very powerful, but getting the best performance requires a lot of manual tweaks and hints
        - Solution: Give more data to the bundler so that it can perform automated decisions
            - Automated resource hints via better static analysis
                - Like preconnect to known hosts
                - Or preload of render critical fonts
                - Also: Priority hints ([https://github.com/WICG/priority-hints](https://github.com/WICG/priority-hints))
                - Problem: What is a render critical font? How to determine the priority
                - Immediate solution: annotate (`/* webpackPrefetch: true */`) [https://medium.com/webpack/link-rel-prefetch-preload-in-webpack-51a52358f84c](https://medium.com/webpack/link-rel-prefetch-preload-in-webpack-51a52358f84c)
            - Automated critical render path tests
                - We feed data back into the bundler
                - Might be able to infer resource hints
                - Create optimized subsets of fonts ([https://www.npmjs.com/package/subfont](https://www.npmjs.com/package/subfont) or [https://www.npmjs.com/package/glyphhanger](https://www.npmjs.com/package/glyphhanger))
                - Inline critical CSS ([https://www.npmjs.com/package/critical](https://www.npmjs.com/package/critical))
                - Plays well with the JAMstack
            - Real usage data via analytics
                - When data decides how to deal with it: Data-driven user experiences
                - Already possible today: Minko Gechev [https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/](https://blog.mgechev.com/2018/03/18/machine-learning-data-driven-bundling-webpack-javascript-markov-chain-angular-react/)
                - Guess ([https://github.com/guess-js/guess](https://github.com/guess-js/guess))
                - Uses probabilities combined with `navigator.connection.effectiveType` to avoid over-fetching and wasting potential expensive data
        - All proposed solutions require deeper knowledge of the application
        - Component-based code splitting will get more important
        - Vue.js is doing a good job, React needs to improve
        - A lot of these solutions are already possible today, but might require a lot of configuration plumbing
    - Automated audits over time
        - Code coverage
        - Performance regressions
        - Not necessarily a task for a bundler but these tools will get more important
    - Tree-shaking, minification, compression
        - The reason why you will always have a build step for high-performance websites
        - Tree-shaking will get better the more hints we can give the bundler

            {
              "name": "project",
              "module": "src/index.js",
              "sideEffects": false
            }

- **Conclusion**
    - Bundlers were invented to use Node.js modules in the web
    - This has changed
    - Now bundlers allow us to use DSLs and dialects for DX reasons
    - And to optimize for better web performance
    - But sharing cross-platform code on NPM is still hard
    - And performance optimizations still require a lot of plumbing
    - My vision:
    - Bundlers should not be necessary because of compatibility reasons (period!)
    - Bundlers should not be necessary to write the code the way we want it
    - In an ideal world, the language and the underlying platform would enable us to write the code the way we want it (without a build tool)
    - When there is no bundler, the transformation will happen on run time
    - When there is a bundler, the static part of the code will be executed on build time
    - Bundlers should only be necessary to make your app fast
    - Because bundlers can do stuff on build time that would otherwise need to be done on run time
    - In order to make that happen we should standardize things that are statically analyzable
    - People can write idiomatic code (Meurer) and the bundler will be able to optimize it
    - We need to give bundlers more insights about our application
        - Via manual hints
        - Via automated critical render path tests
        - Via real usage data
                -->
            </div>
        </div>
        <template id="feature-table">
            <style>
                table {
                    margin: auto;
                    border-collapse: collapse;
                    border-spacing: 0;
                }

                table th {
                    font-weight: bold;
                    font-size: 2rem;
                }

                table th,
                table td {
                    text-align: left;
                    padding: 0.2em 0.5em 0.2em 0.5em;
                    border-bottom: 1px solid;
                }

                table tbody tr:last-child th,
                table tbody tr:last-child td {
                    border-bottom: none;
                }
                td > div {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
            </style>
            <table>
                <thead>
                    <tr>
                        <th>Dev experience</th>
                        <th>Compatibility</th>
                        <th>Optimization</th>
                    </tr>
                </thead>
                <tbody style="font-size: 2rem">
                    <tr>
                        <td>
                            <div>
                                <span>JS modules</span>
                                <span><slot name="js-modules">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>Unified module systems</span>
                                <span><slot name="unified-module-systems">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>Efficient chunks</span>
                                <span><slot name="efficient-chunks">&nbsp;</slot></span>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div>
                                <span>HTML, CSS & WASM modules</span>
                                <span><slot name="html-css-wasm-modules">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>Unified platform</span>
                                <span><slot name="unified-platform">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>Long-term caching</span>
                                <span><slot name="long-term-caching">&nbsp;</slot></span>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div>
                                <span>Custom languages</span>
                                <span><slot name="custom-languages">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>New language features</span>
                                <span><slot name="new-language-features">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td>
                            <div>
                                <span>Resource hints</span>
                                <span><slot name="resource-hints">&nbsp;</slot></span>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div>
                                <span>Short feedback loop</span>
                                <span><slot name="short-feedback-loop">&nbsp;</slot></span>
                            </div>
                        </td>
                        <td></td>
                        <td>
                            <div>
                                <span>Smaller file sizes</span>
                                <span><slot name="smaller-file-sizes">&nbsp;</slot></span>
                            </div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </template>
        <script>
            class FeatureTable extends HTMLElement {
                constructor() {
                    super();
                    const template = document.getElementById("feature-table");

                    this.attachShadow({ mode: "open" }).appendChild(
                        template.content.cloneNode(true)
                    );
                }
            }

            window.customElements.define("feature-table", FeatureTable);
        </script>
        <template id="checkmark">
            <span style="display: block; width: 1em; text-align: center; color: #0b8649;">✔</span>
            <span style="display: block; width: 1em; text-align: center; color: #b98404; font-weight: bolder; font-size: 1.3em;">?</span>
            <span style="display: block; width: 1em; text-align: center; color: #0b8649;">✗</span>
        </template>
        <script>
            class Checkmark extends HTMLElement {
                constructor() {
                    const values = {
                        ok: 0,
                        maybe: 1,
                        problem: 2
                    };

                    super();
                    const template = document.getElementById("checkmark");
                    const value = this.getAttribute("value");
                    const index = values[value];

                    if (index === undefined) {
                        throw new Error(`Unkown value "${value}"`);
                    }

                    this.appendChild(template.content.children[index].cloneNode(true));
                }
            }

            window.customElements.define("check-mark", Checkmark);
        </script>
        <script src="../asset/vendor/prism-1.15.0/prism.js"></script>
        <script src="../asset/vendor/reveal-alt-arrows/alt-arrows.js"></script>
        <script src="../asset/vendor/reveal.js-3.7.0/js/reveal.js"></script>
        <script src="../asset/peerigon/colorScheme.js"></script>
        <script>
            Reveal.initialize({
                history: true,
                keyboard: {
                    39: "next", // Right Arrow
                    37: "prev", // Left Arrow
                },
            });
        </script>
    </body>
</html>
